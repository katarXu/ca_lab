# 计算机体系结构Lab2



<p align="right">PB18000334 徐家恒</p>

## 实验目标

用verilog去实现RV32I 流水线CPU



## 实验环境

* **实验工具**：Vivado
* **实验方式**：Vivado自带的波形仿真



## 实验要求

能正确运行包括各指令的测试集生成的文件并处理数据相关



## 实验内容

#### NPC模块

```verilog
module NPC_Generator(
    input wire [31:0] PCF,JalrTarget, BranchTarget, JalTarget,
    input wire BranchE,JalD,JalrE,
    output reg [31:0] PC_In
    );
    always@(*)
    begin
        if(BranchE) PC_In <= BranchTarget;
        else if(JalrE) PC_In <= JalrTarget;
        else if(JalD) PC_In <= JalTarget;
        else PC_In <= PCF + 4;
    end
endmodule
```

​	根据对应的信号确定下一个指令地址即可

#### 控制信号模块

```Verilog
assign LoadNpcD = JalD | JalrD ;
assign JalD = (Op == 7'b1101111) ? 1'b1 : 1'b0;
assign JalrD = (Op == 7'b1100111) ? 1'b1 : 1'b0;
assign MemToRegD = (Op == 7'b0000011) ? 1'b1 : 1'b0;
assign AluSrc1D = (Op == 7'b0010111) ? 1'b1 : 1'b0;

reg [1: 0] AluSrc2DReg;
assign AluSrc2D = AluSrc2DReg;
```

​	根据信号的Op字段确定部分控制信号

```verilog
always@(*) 
begin
    if ((Op == 7'b0010011) && (Fn3[1: 0] == 2'b01))
        AluSrc2DReg <= 2'b01;
    else if ( (Op == 7'b0110011) || (Op == 7'b1100011) )
        AluSrc2DReg <= 2'b00 ;
    else
        AluSrc2DReg <= 2'b10;
end
```

​	根据是否是否是RTYPE和ITYPE指令确定AluSrc

```verilog
always@(*) 
begin
    case (ImmType)
        `RTYPE: RegReadD = 2'b11;
        `ITYPE: RegReadD = 2'b10;
        `STYPE: RegReadD = 2'b11;
        `BTYPE: RegReadD = 2'b11;
        `UTYPE: RegReadD = 2'b00;
        `JTYPE: RegReadD = 2'b00;
        default: RegReadD = 2'b00;
    endcase
end
```

​	根据指令类型确定A1、A2寄存器是否被用到



后续有根据具体指令确定的AluControl信号等，详见代码

#### 立即数模块

```verilog
always@(*)
    begin
        case(Type)
            `ITYPE: Out <= { {21{In[31]}}, In[30: 20] };
            `STYPE: Out <= {{21{In[31]}}, In[30: 25], In[11: 7]};
            `BTYPE: Out <= {{20{In[31]}}, In[7], In[30: 25], In[11: 8], 1'b0};
            `UTYPE: Out <= {In[31: 12], 12'b0};
            `JTYPE: Out <= {{12{In[31]}}, In[19: 12], In[20], In[30: 21], 1'b0};
            default:Out<=32'hxxxxxxxx;
        endcase
    end
```

​	根据文档确定各类型指令类型对应的立即数即可



#### ALU模块

```verilog
always @(*) 
begin
    case (AluContrl)
    `ADD: AluOut <= Operand1 + Operand2;
    `SUB: AluOut <= Operand1 - Operand2;
    `SLL: AluOut <= Operand1 << Operand2[4: 0];
    `SRL: AluOut <= Operand1 >> Operand2[4: 0];
    `SRA: AluOut <= $signed(Operand1) >>> Operand2[4: 0];
    `XOR: AluOut <= Operand1 ^ Operand2;
    `OR: AluOut <= Operand1 | Operand2;
    `AND: AluOut <= Operand1 & Operand2;
    `SLT: AluOut <= ($signed(Operand1) < $signed(Operand2)) ? 32'h1 : 32'h0;
    `SLTU: AluOut <= (Operand1 < Operand2) ? 32'h1 : 32'h0;
    `LUI: AluOut <= (Operand2) & 32'hfffff000;
    default: AluOut <= 32'hxxxxxxxx;
endcase	
```

​	根据对应控制信号执行即可



#### 分支模块

```verilog
always @( * ) begin
case (BranchTypeE)
    `BEQ: BranchE <= (Operand1 == Operand2) ? 1'b1 : 1'b0;
    `BNE: BranchE <= (Operand1 == Operand2) ? 1'b0 : 1'b1;
    `BLT: BranchE <= ($signed(Operand1) < $signed(Operand2) ) ? 1'b1 : 1'b0;
    `BLTU: BranchE <= (Operand1 < Operand2) ? 1'b1 : 1'b0;
    `BGE: BranchE <= ($signed(Operand1) >= $signed(Operand2) ) ? 1'b1 : 1'b0;
    `BGEU: BranchE <= (Operand1 >= Operand2) ? 1'b1 : 1'b0;
    default: BranchE <= 1'b0;
endcase
```
​	根据对应控制信号执行即可

#### 数据拓展模块

```verilog
always@(*) 
begin
    case (RegWriteW)
        `LB: OUT <= {{24{LoadByte[7]}}, LoadByte[7: 0]};
        `LH: OUT <= {{16{LoadHalfWord[15]}}, LoadHalfWord[15: 0]};
        `LW: OUT <= IN;
        `LBU: OUT <= {24'h0, LoadByte[7: 0]};
        `LHU: OUT <= {16'h0, LoadHalfWord[15: 0]};
    endcase
end  
```
​	根据控制信号确定要拓展的数位

#### 冒险模块

```verilog
always @ (*)
    if(CpuRst)
        {StallF,FlushF,StallD,FlushD,StallE,FlushE,StallM,FlushM,StallW,FlushW} <= 10'b0101010101;
	//初始化，将所有stall置零，flush置1
    else if(DCacheMiss | ICacheMiss)
        {StallF,FlushF,StallD,FlushD,StallE,FlushE,StallM,FlushM,StallW,FlushW} <= 10'b1010101010;
	//cache miss时，将所有stall置1，flush置0
    else if(BranchE | JalrE)
        {StallF,FlushF,StallD,FlushD,StallE,FlushE,StallM,FlushM,StallW,FlushW} <= 10'b0001010000;
	//EX段出现分支时，将ID、EX段flush置1
    else if(MemToRegE & ((RdE==Rs1D)||(RdE==Rs2D)) )
        {StallF,FlushF,StallD,FlushD,StallE,FlushE,StallM,FlushM,StallW,FlushW} <= 10'b1010010000;
	//读后写，将要写的地方stall，要读的地方flush
    else if(JalD)
        {StallF,FlushF,StallD,FlushD,StallE,FlushE,StallM,FlushM,StallW,FlushW} <= 10'b0001000000;
	//ID段出现分支时，将ID段flush置1
    else
        {StallF,FlushF,StallD,FlushD,StallE,FlushE,StallM,FlushM,StallW,FlushW} <= 10'b0000000000;
//Forward Register Source 1
always@(*)begin
    if( (RegWriteM!=3'b0) && (RegReadE[1]!=0) && (RdM==Rs1E) &&(RdM!=5'b0) )
        Forward1E<=2'b10;
    else if( (RegWriteW!=3'b0) && (RegReadE[1]!=0) && (RdW==Rs1E) &&(RdW!=5'b0) )
        Forward1E<=2'b01;
    else
        Forward1E<=2'b00;
end
//Forward Register Source 2
always@(*)begin
    if( (RegWriteM!=3'b0) && (RegReadE[0]!=0) && (RdM==Rs2E) &&(RdM!=5'b0) )
        Forward2E<=2'b10;
    else if( (RegWriteW!=3'b0) && (RegReadE[0]!=0) && (RdW==Rs2E) &&(RdW!=5'b0) )
        Forward2E<=2'b01;
    else
        Forward2E<=2'b00;
end 
//转发的情况
```


#### 实验总结

控制单元模块看上去只需要将对应的指令翻译一下，但实现起来还是比较复杂，毕竟有很多单独的指令，同种类型的指令的Op段也不一定一样

冒险模块一开始不是很懂，部分借鉴了网上的代码

写完之后回头看写的都是比较基础的东西，但还是用了两个下午的时间来写。可能还是需要详细一点的框架吧。